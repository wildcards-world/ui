// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import BnJs from "bn.js";
import * as React from "react";
import * as Belt_Int from "bs-platform/lib/es6/belt_Int.js";
import * as RimbleUi from "rimble-ui";
import * as Belt_Float from "bs-platform/lib/es6/belt_Float.js";
import * as Web3Utils from "web3-utils";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Core from "@web3-react/core";
import * as Animal$WildCards from "../Animal.bs.js";
import * as Styles$WildCards from "../../Styles.bs.js";
import * as Globals$WildCards from "../Globals.bs.js";
import * as QlHooks$WildCards from "../QlHooks.bs.js";
import * as TokenId$WildCards from "../TokenId.bs.js";
import * as BuyInput$WildCards from "./BuyInput.bs.js";
import * as CONSTANTS$WildCards from "../../CONSTANTS.bs.js";
import * as InputHelp$WildCards from "../InputHelp.bs.js";
import * as Web3Utils$WildCards from "../Web3Utils.bs.js";
import * as Accounting$WildCards from "../Accounting.bs.js";
import * as TxTemplate$WildCards from "../../components/components/TxTemplate.bs.js";
import * as RootProvider$WildCards from "../RootProvider.bs.js";
import * as ContractActions$WildCards from "../eth/ContractActions.bs.js";

function calcPricePerSecond(price, numerator, denominator) {
  var priceBn = new BnJs(price);
  var numeratorBn = new BnJs(numerator);
  var denominatorBn = new BnJs(denominator);
  var fullYearSeconds = new BnJs("31536000");
  return priceBn.mul(numeratorBn).div(denominatorBn).div(fullYearSeconds);
}

function calculateDepositDuration(deposit, price, numerator, denominator) {
  var depositBn = new BnJs(deposit);
  var pricePerSecond = calcPricePerSecond(price, numerator, denominator);
  return Accounting$WildCards.defaultZeroI(Belt_Int.fromString(depositBn.div(pricePerSecond.gt(new BnJs("0")) ? pricePerSecond : new BnJs("1")).toString()));
}

function calcRequiredDepositForTime(time, price, numerator, denominator) {
  var timeBn = new BnJs(String(time));
  var pricePerSecond = calcPricePerSecond(price, numerator, denominator);
  return Web3Utils$WildCards.fromWeiToEth(timeBn.mul(pricePerSecond).toString());
}

function Buy$Buy(Props) {
  var chain = Props.chain;
  var tokenId = Props.tokenId;
  var availableBalance = Props.availableBalance;
  var web3Context = Core.useWeb3React();
  var match = ContractActions$WildCards.useBuy(chain, tokenId, web3Context.library, web3Context.account, Belt_Option.getWithDefault(web3Context.chainId, 1));
  var buyFunc = match[0];
  var match$1 = ContractActions$WildCards.useBuyAuction(chain, tokenId, web3Context.library, web3Context.account, Belt_Option.getWithDefault(web3Context.chainId, 1));
  var buyFuncAuction = match$1[0];
  var userBalance = Belt_Option.mapWithDefault(RootProvider$WildCards.useEthBalance(undefined), new BnJs("0"), (function (a) {
          return a;
        }));
  var match$2 = QlHooks$WildCards.usePledgeRateDetailed(chain, tokenId);
  var ratio = match$2[2];
  var denominator = match$2[1];
  var numerator = match$2[0];
  var priceStatus = QlHooks$WildCards.usePrice(chain, tokenId);
  var isOnAuction = Animal$WildCards.useIsOnAuction(chain, tokenId);
  var launchTimeOpt = QlHooks$WildCards.useLaunchTimeBN(chain, tokenId);
  var currentPriceWei = Animal$WildCards.useAuctionPriceWei(chain, tokenId, Belt_Option.getWithDefault(launchTimeOpt, new BnJs("5000")));
  var currentPriceWei$1 = isOnAuction ? Belt_Option.getWithDefault(currentPriceWei, new BnJs("0")) : (
      typeof priceStatus === "number" ? new BnJs("0") : (
          priceStatus.TAG ? priceStatus._0 : new BnJs("0")
        )
    );
  var tokenIdName = "token#" + TokenId$WildCards.toString(tokenId);
  var maxAvailableDepositBN = Belt_Option.getWithDefault(availableBalance, userBalance.sub(new BnJs("3000000000000000")).sub(currentPriceWei$1));
  var maxAvailableDeposit = Web3Utils$WildCards.fromWeiToEth(maxAvailableDepositBN.toString());
  var isAbleToBuy = maxAvailableDepositBN.gt(new BnJs("0"));
  var currentPriceEth = Web3Utils$WildCards.fromWeiBNToEth(currentPriceWei$1);
  var currentPriceFloat = Accounting$WildCards.defaultZeroF(Belt_Float.fromString(currentPriceEth));
  var currentPriceFloatWithMinimum = Math.max(currentPriceFloat, 0.005);
  var defaultPriceValue = Globals$WildCards.toFixedWithPrecisionNoTrailingZeros(currentPriceFloatWithMinimum * 1.5, 2);
  var defaultMonthlyPatronage = Globals$WildCards.toFixedWithPrecisionNoTrailingZeros(currentPriceFloatWithMinimum * 1.5 * ratio, 3);
  var defaultPriceWei = Web3Utils$WildCards.toWeiFromEth(defaultPriceValue);
  var depositForAYear = calcRequiredDepositForTime(31536000, defaultPriceWei, numerator, denominator);
  var match$3 = Caml_format.caml_float_of_string(depositForAYear) < Caml_format.caml_float_of_string(maxAvailableDeposit) ? [
      31536000,
      depositForAYear
    ] : [
      calculateDepositDuration(Web3Utils$WildCards.toWeiFromEth(maxAvailableDeposit), defaultPriceWei, numerator, denominator),
      Math.max(0, Caml_format.caml_float_of_string(maxAvailableDeposit)).toString()
    ];
  var defaultDeposit = match$3[1];
  var defaultDepositTime = match$3[0];
  var match$4 = React.useState(function () {
        return defaultPriceValue;
      });
  var setInitialPrice = match$4[1];
  var newPrice = match$4[0];
  var match$5 = React.useState(function () {
        return defaultMonthlyPatronage;
      });
  var setPatronage = match$5[1];
  var match$6 = React.useState(function () {
        return defaultDeposit;
      });
  var setInitialDeposit = match$6[1];
  var deposit = match$6[0];
  var match$7 = React.useState(function () {
        return defaultDepositTime;
      });
  var setDepositTimeInSeconds = match$7[1];
  var onSubmitBuy = function (param) {
    var amountToSend = currentPriceWei$1.add(new BnJs(Web3Utils.toWei(deposit, "ether")));
    if (typeof priceStatus !== "number" && priceStatus.TAG) {
      if (priceStatus._0.gt(new BnJs("0"))) {
        return Curry._4(buyFunc, newPrice, currentPriceWei$1.toString(), "150000", amountToSend.toString());
      } else {
        return Curry._3(buyFuncAuction, newPrice, "150000", amountToSend.add(new BnJs("1000000000000000")).toString());
      }
    }
    return Curry._3(buyFuncAuction, newPrice, "150000", amountToSend.add(new BnJs("1000000000000000")).toString());
  };
  var setNewPrice = function (value) {
    var match = InputHelp$WildCards.onlyUpdateValueIfPositiveFloat(newPrice, setInitialPrice, value);
    if (!match[1]) {
      return ;
    }
    var value$1 = match[0];
    var patronage = (Accounting$WildCards.defaultZeroF(Belt_Float.fromString(value$1)) * ratio).toString();
    Curry._1(setPatronage, (function (param) {
            return patronage;
          }));
    var timeInSeconds = calculateDepositDuration(Web3Utils$WildCards.toWeiFromEth(deposit), Web3Utils$WildCards.toWeiFromEth(value$1), numerator, denominator);
    return Curry._1(setDepositTimeInSeconds, (function (param) {
                  return timeInSeconds;
                }));
  };
  var setDeposit = function (value) {
    var match = InputHelp$WildCards.onlyUpdateValueIfInRangeFloat(0, Caml_format.caml_float_of_string(maxAvailableDeposit), deposit, setInitialDeposit, value);
    if (!match[1]) {
      return ;
    }
    var timeInSeconds = calculateDepositDuration(Web3Utils$WildCards.toWeiFromEth(match[0]), Web3Utils$WildCards.toWeiFromEth(newPrice), numerator, denominator);
    return Curry._1(setDepositTimeInSeconds, (function (param) {
                  return timeInSeconds;
                }));
  };
  var currency = chain !== 1 ? "ether" : "DAI";
  return React.createElement(TxTemplate$WildCards.make, {
              children: React.createElement(TxTemplate$WildCards.make, {
                    children: isAbleToBuy ? React.createElement(BuyInput$WildCards.make, {
                            patronage: match$5[0],
                            onSubmitBuy: onSubmitBuy,
                            newPrice: newPrice,
                            deposit: deposit,
                            depositTimeInSeconds: match$7[0],
                            maxAvailableDeposit: maxAvailableDeposit,
                            setNewPrice: setNewPrice,
                            setDeposit: setDeposit,
                            tokenIdName: tokenIdName
                          }) : React.createElement(RimbleUi.Box, {
                            children: React.createElement("p", {
                                  className: Styles$WildCards.textOnlyModalText
                                }, "You do not have enough " + (currency + (" to buy " + (tokenIdName + "."))))
                          }),
                    txState: match[1],
                    closeButtonText: "Back to view Animal",
                    chain: chain
                  }),
              txState: match$1[1],
              closeButtonText: "Back to view Animal",
              chain: chain
            });
}

var Buy = {
  make: Buy$Buy
};

function Buy$1(Props) {
  var chain = Props.chain;
  var tokenId = Props.tokenId;
  var web3Context = Core.useWeb3React();
  var arg = Belt_Option.getWithDefault(web3Context.account, CONSTANTS$WildCards.nullEthAddress);
  var optMaticState = Curry._1((function (param) {
            return function (param$1) {
              return QlHooks$WildCards.useMaticState(param, arg, param$1);
            };
          })(false), ContractActions$WildCards.getMaticNetworkName(ContractActions$WildCards.getChildChainId(Belt_Option.getWithDefault(web3Context.chainId, 1))));
  if (chain !== 1) {
    return React.createElement(Buy$Buy, {
                chain: chain,
                tokenId: tokenId
              });
  }
  if (optMaticState === undefined) {
    return React.createElement("p", undefined, "Updating latest state.");
  }
  var maticState = Caml_option.valFromOption(optMaticState);
  var error = maticState.error;
  if (error !== undefined) {
    console.log("matic state fetch error", error);
    return React.createElement("p", undefined, "Error: Unable to get matic state - please try again or contact the Wildcards Team.");
  } else {
    return React.createElement(Buy$Buy, {
                chain: chain,
                tokenId: tokenId,
                availableBalance: new BnJs(maticState.balance)
              });
  }
}

var make = Buy$1;

export {
  calcPricePerSecond ,
  calculateDepositDuration ,
  calcRequiredDepositForTime ,
  Buy ,
  make ,
  
}
/* bn.js Not a pure module */
